package main

import (
	"bytes"
	"fmt"
	"go/format"
)

func GenerateCode(pkgname, funcname string, prog *Program) ([]byte, error) {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by gen; DO NOT EDIT.")
	fmt.Fprintln(&buf, "")
	fmt.Fprintf(&buf, "package %s\n", pkgname)
	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, "import (")
	fmt.Fprintln(&buf, `	"github.com/khirono/go-peg"`)
	fmt.Fprintln(&buf, ")")
	fmt.Fprintln(&buf, "")
	fmt.Fprintf(&buf, "func %s() peg.Expr {\n", funcname)

	for _, stmt := range prog.Stmts {
		fmt.Fprintf(&buf, "\t%s := peg.NewRule(\"%s\")\n", stmt.Ident.Name, stmt.Ident.Name)
	}
	fmt.Fprintln(&buf, "")

	for _, stmt := range prog.Stmts {
		fmt.Fprintf(&buf, "\t%s.Define(\n", stmt.Ident.Name)
		GenerateCodeExpr(&buf, stmt.Expr)
		fmt.Fprintf(&buf, ")\n")
	}

	fmt.Fprintf(&buf, "\treturn %s\n", prog.Stmts[0].Ident.Name)

	fmt.Fprintln(&buf, "}")

	return format.Source(buf.Bytes())
}

func GenerateCodeExpr(buf *bytes.Buffer, expr Expr) error {
	switch expr := expr.(type) {
	case *ChoiceExpr:
		fmt.Fprintln(buf, "peg.NewChoice(")
		for _, child := range expr.Exprs {
			GenerateCodeExpr(buf, child)
		}
		fmt.Fprintln(buf, "),")
	case *SequenceExpr:
		fmt.Fprintln(buf, "peg.NewSequence(")
		for _, child := range expr.Exprs {
			GenerateCodeExpr(buf, child)
		}
		fmt.Fprintln(buf, "),")
	case *ZeroOrMoreExpr:
		fmt.Fprintln(buf, "peg.NewZeroOrMore(")
		GenerateCodeExpr(buf, expr.Expr)
		fmt.Fprintln(buf, "),")
	case *OneOrMoreExpr:
		fmt.Fprintln(buf, "peg.NewOneOrMore(")
		GenerateCodeExpr(buf, expr.Expr)
		fmt.Fprintln(buf, "),")
	case *RepeatExpr:
		fmt.Fprintln(buf, "peg.NewRepeat(")
		GenerateCodeExpr(buf, expr.Expr)
		GenerateCodeLimit(buf, &expr.Limit)
		fmt.Fprintln(buf, "),")
	case *OptionalExpr:
		fmt.Fprintln(buf, "peg.NewOptional(")
		GenerateCodeExpr(buf, expr.Expr)
		fmt.Fprintln(buf, "),")
	case *AndExpr:
		fmt.Fprintln(buf, "peg.NewAnd(")
		GenerateCodeExpr(buf, expr.Expr)
		fmt.Fprintln(buf, "),")
	case *NotExpr:
		fmt.Fprintln(buf, "peg.NewNot(")
		GenerateCodeExpr(buf, expr.Expr)
		fmt.Fprintln(buf, "),")
	case *Charclass:
		fmt.Fprintln(buf, "peg.NewCharclass(")
		if expr.Invert {
			fmt.Fprintln(buf, "peg.RuneInvert{")
			GenerateCodeCharRange(buf, expr.Set)
			fmt.Fprintln(buf, "},")
		} else {
			GenerateCodeCharRange(buf, expr.Set)
		}
		fmt.Fprintln(buf, "),")
	case *Literal:
		fmt.Fprintln(buf, "peg.NewLiteral(")
		fmt.Fprintf(buf, "%q,\n", expr.Text)
		fmt.Fprintln(buf, "),")
	case *Ident:
		fmt.Fprintf(buf, "%s,\n", expr.Name)
	case *Any:
		fmt.Fprintln(buf, "peg.Any,")
	case *EOT:
		fmt.Fprintln(buf, "peg.EOT,")
	default:
		return fmt.Errorf("unknown type: %T", expr)
	}
	return nil
}

func GenerateCodeCharRange(buf *bytes.Buffer, set []CharRange) error {
	if len(set) == 1 {
		r := set[0]
		if r.Lower == r.Upper {
			fmt.Fprintf(buf, "peg.RuneValue(%#v),\n", r.Lower)
		} else {
			fmt.Fprintf(buf, "peg.RuneRange{%#v, %#v},\n", r.Lower, r.Upper)
		}
		return nil
	}
	fmt.Fprintln(buf, "peg.RuneUnion{")
	for _, r := range set {
		if r.Lower == r.Upper {
			fmt.Fprintf(buf, "peg.RuneValue(%#v),\n", r.Lower)
		} else {
			fmt.Fprintf(buf, "peg.RuneRange{%#v, %#v},\n", r.Lower, r.Upper)
		}
	}
	fmt.Fprintln(buf, "},")
	return nil
}

func GenerateCodeLimit(buf *bytes.Buffer, l *Limit) error {
	switch {
	case l.LowerValid && l.UpperValid:
		fmt.Fprintf(buf, "peg.NewLimit(%v, %v),\n", l.Lower, l.Upper)
	case l.LowerValid:
		fmt.Fprintf(buf, "peg.NewLimitLower(%v),\n", l.Lower)
	case l.UpperValid:
		fmt.Fprintf(buf, "peg.NewLimitUpper(%v),\n", l.Upper)
	default:
		return fmt.Errorf("not found limit valid")
	}
	return nil
}
